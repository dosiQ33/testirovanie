# Common Address Registry

## 1. DB structure

```sql
create schema ar;


create table ar.d_ats_types
(
    created_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by     integer,
    updated_by     integer,
    id             integer generated by default as identity
        constraint "PK_854241cbaa502f4640a2effe11e"
            primary key,
    code           integer                                                      not null,
    value_kz       varchar                                                      not null,
    value_ru       varchar                                                      not null,
    short_value_kz varchar,
    short_value_ru varchar,
    actual         boolean                                                      not null
);

comment on table ar.d_ats_types is 'Типы административно-территориальных единиц';
comment on column ar.d_ats_types.created_at is 'Дата-Время создания записи';
comment on column ar.d_ats_types.updated_at is 'Дата-Время обновления записи';
comment on column ar.d_ats_types.created_by is 'Кем создано';
comment on column ar.d_ats_types.updated_by is 'Кем обновлено';
comment on column ar.d_ats_types.code is 'Код';
comment on column ar.d_ats_types.value_kz is 'Наименование КАЗ';
comment on column ar.d_ats_types.value_ru is 'Наименование РУС';
comment on column ar.d_ats_types.short_value_kz is 'Наименование КАЗ';
comment on column ar.d_ats_types.short_value_ru is 'Наименование РУС';
comment on column ar.d_ats_types.actual is 'Действующее';




create table ar.d_buildings_pointers
(
    created_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by     integer,
    updated_by     integer,
    id             integer generated by default as identity
        constraint "PK_8a8596fa601c6e62577504e07f5"
            primary key,
    code           integer                                                      not null,
    value_kz       varchar                                                      not null,
    value_ru       varchar                                                      not null,
    short_value_kz varchar,
    short_value_ru varchar,
    actual         boolean                                                      not null
);

comment on table ar.d_buildings_pointers is 'Указатели типов первичных объектов недвижимости';
comment on column ar.d_buildings_pointers.created_at is 'Дата-Время создания записи';
comment on column ar.d_buildings_pointers.updated_at is 'Дата-Время обновления записи';
comment on column ar.d_buildings_pointers.created_by is 'Кем создано';
comment on column ar.d_buildings_pointers.updated_by is 'Кем обновлено';
comment on column ar.d_buildings_pointers.code is 'Код';
comment on column ar.d_buildings_pointers.value_kz is 'Наименование КАЗ';
comment on column ar.d_buildings_pointers.value_ru is 'Наименование РУС';
comment on column ar.d_buildings_pointers.short_value_kz is 'Наименование КАЗ';
comment on column ar.d_buildings_pointers.short_value_ru is 'Наименование РУС';
comment on column ar.d_buildings_pointers.actual is 'Действующее';




create table ar.d_geonims_types
(
    created_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by     integer,
    updated_by     integer,
    id             integer generated by default as identity
        constraint "PK_e9d6e05846fe9b3a52d905e5b6d"
            primary key,
    code           integer                                                      not null,
    value_kz       varchar                                                      not null,
    value_ru       varchar                                                      not null,
    short_value_kz varchar,
    short_value_ru varchar,
    actual         boolean                                                      not null,
    this_is        varchar
);

comment on table ar.d_geonims_types is 'Типы составных частей населенных пунктов';
comment on column ar.d_geonims_types.created_at is 'Дата-Время создания записи';
comment on column ar.d_geonims_types.updated_at is 'Дата-Время обновления записи';
comment on column ar.d_geonims_types.created_by is 'Кем создано';
comment on column ar.d_geonims_types.updated_by is 'Кем обновлено';
comment on column ar.d_geonims_types.code is 'Код';
comment on column ar.d_geonims_types.value_kz is 'Наименование КАЗ';
comment on column ar.d_geonims_types.value_ru is 'Наименование РУС';
comment on column ar.d_geonims_types.short_value_kz is 'Наименование КАЗ';
comment on column ar.d_geonims_types.short_value_ru is 'Наименование РУС';
comment on column ar.d_geonims_types.actual is 'Действующее';
comment on column ar.d_geonims_types.this_is is 'Дорога';



create table ar.d_rooms_types
(
    created_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by     integer,
    updated_by     integer,
    id             integer generated by default as identity
        constraint "PK_d17963f6ab0f76b95ad81806e6a"
            primary key,
    code           integer                                                      not null,
    value_kz       varchar                                                      not null,
    value_ru       varchar                                                      not null,
    short_value_kz varchar,
    short_value_ru varchar,
    actual         boolean                                                      not null
);

comment on table ar.d_rooms_types is 'Типы помещений';
comment on column ar.d_rooms_types.created_at is 'Дата-Время создания записи';
comment on column ar.d_rooms_types.updated_at is 'Дата-Время обновления записи';
comment on column ar.d_rooms_types.created_by is 'Кем создано';
comment on column ar.d_rooms_types.updated_by is 'Кем обновлено';
comment on column ar.d_rooms_types.code is 'Код';
comment on column ar.d_rooms_types.value_kz is 'Наименование КАЗ';
comment on column ar.d_rooms_types.value_ru is 'Наименование РУС';
comment on column ar.d_rooms_types.short_value_kz is 'Наименование КАЗ';
comment on column ar.d_rooms_types.short_value_ru is 'Наименование РУС';
comment on column ar.d_rooms_types.actual is 'Действующее';




create table ar.s_ats
(
    created_at    timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at    timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by    integer,
    updated_by    integer,
    id            integer generated by default as identity
        constraint "PK_96fb72e6b8d38594324f10df748"
            primary key,
    path          jsonb,
    path_names_ru varchar[],
    path_names_kz varchar[],
    is_leaf       boolean   default false                                      not null,
    full_address_ru  varchar,
    full_address_kz  varchar,
    rco           varchar,
    cato          varchar,
    name_kz       varchar                                                      not null,
    name_ru       varchar                                                      not null,
    actual        boolean                                                      not null,
    shape         geometry(MultiPolygon, 4326),
    parent_id     integer
        constraint "FK_83541725f5a282dc67014502f11"
            references ar.s_ats,
    d_ats_type_id integer
        constraint "FK_dffdc6cca04377bf2a95f9c0d4b"
            references ar.d_ats_types
);

comment on table ar.s_ats is 'Административно-территориальные единицы';
comment on column ar.s_ats.created_at is 'Дата-Время создания записи';
comment on column ar.s_ats.updated_at is 'Дата-Время обновления записи';
comment on column ar.s_ats.created_by is 'Кем создано';
comment on column ar.s_ats.updated_by is 'Кем обновлено';
comment on column ar.s_ats.path is 'Полный путь';
comment on column ar.s_ats.is_leaf is 'Крайний элемент';
comment on column ar.s_ats.full_address_ru is 'Полный путь наименований РУС';
comment on column ar.s_ats.full_address_kz is 'Полный путь наименований КАЗ';
comment on column ar.s_ats.rco is 'Код РКО';
comment on column ar.s_ats.cato is 'Код КАТО';
comment on column ar.s_ats.name_kz is 'Наименование КАЗ';
comment on column ar.s_ats.name_ru is 'Наименование РУС';
comment on column ar.s_ats.actual is 'Действующее';

create index "IDX_11a55627ebdf50042059f6f0a1"
    on ar.s_ats (full_address_ru);

create index "IDX_32c0dde395159df2b441a9c611"
    on ar.s_ats (full_address_kz);

create index "IDX_83541725f5a282dc67014502f1"
    on ar.s_ats (parent_id);

create index "IDX_dffdc6cca04377bf2a95f9c0d4"
    on ar.s_ats (d_ats_type_id);

create index if not exists "IDX_s_ats_shape"
    on ar.s_ats using gist (shape);

create table ar.s_ats_closure
(
    id_ancestor   integer not null
        constraint "FK_2ebca8efb8574335a5129cc8b2b"
            references ar.s_ats
            on delete cascade,
    id_descendant integer not null
        constraint "FK_790d8bf4e62f16295e0841cafc6"
            references ar.s_ats
            on delete cascade,
    constraint "PK_76b4896cfc1028ddbd44caafe3d"
        primary key (id_ancestor, id_descendant)
);

create index "IDX_2ebca8efb8574335a5129cc8b2"
    on ar.s_ats_closure (id_ancestor);

create index "IDX_790d8bf4e62f16295e0841cafc"
    on ar.s_ats_closure (id_descendant);



create table ar.s_geonims
(
    created_at        timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at        timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by        integer,
    updated_by        integer,
    id                integer generated by default as identity
        constraint "PK_84e76b611d020510fe5235316d4"
            primary key,
    rco               varchar,
    cato              varchar,
    name_kz           varchar                                                      not null,
    name_ru           varchar                                                      not null,
    full_address_ru   varchar,
    full_address_kz   varchar,
    actual            boolean                                                      not null,
    path              jsonb,
    path_names_ru     varchar[],
    path_names_kz     varchar[],
    is_leaf           boolean   default false                                      not null,
    shape             geometry(MultiPolygon, 4326),
    parent_id         integer
        constraint "FK_c9f900867dca8c0cf2f719122bd"
            references ar.s_geonims,
    s_ats_id          integer                                                      not null
        constraint "FK_e75e190873a8f28ec7e539c458c"
            references ar.s_ats,
    d_geonims_type_id integer                                                      not null
        constraint "FK_9de69df1afe8c32951451e39341"
            references ar.d_geonims_types
);

comment on table ar.s_geonims is 'Части населённых пунктов';
comment on column ar.s_geonims.created_at is 'Дата-Время создания записи';
comment on column ar.s_geonims.updated_at is 'Дата-Время обновления записи';
comment on column ar.s_geonims.created_by is 'Кем создано';
comment on column ar.s_geonims.updated_by is 'Кем обновлено';
comment on column ar.s_geonims.rco is 'Код РКО';
comment on column ar.s_geonims.cato is 'Код КАТО';
comment on column ar.s_geonims.name_kz is 'Наименование КАЗ';
comment on column ar.s_geonims.name_ru is 'Наименование РУС';
comment on column ar.s_geonims.actual is 'Действующее';

create index "IDX_c076ca8fb07918a0e24bf4c465"
    on ar.s_geonims (name_kz);

create index "IDX_c3bdada553253970ec7e971b71"
    on ar.s_geonims (name_ru);

create index "IDX_c9f900867dca8c0cf2f719122b"
    on ar.s_geonims (parent_id);

create index "IDX_e75e190873a8f28ec7e539c458"
    on ar.s_geonims (s_ats_id);

create index "IDX_9de69df1afe8c32951451e3934"
    on ar.s_geonims (d_geonims_type_id);

create index if not exists "IDX_s_geonims_shape"
    on ar.s_geonims using gist (shape);

create table ar.s_geonims_closure
(
    id_ancestor   integer not null
        constraint "FK_5445373cf9320be46e75ba9b45d"
            references ar.s_geonims
            on delete cascade,
    id_descendant integer not null
        constraint "FK_e7314467f7167fd72cf601e6466"
            references ar.s_geonims
            on delete cascade,
    constraint "PK_82dad04a49a51594b46c6318a60"
        primary key (id_ancestor, id_descendant)
);

create index "IDX_5445373cf9320be46e75ba9b45"
    on ar.s_geonims_closure (id_ancestor);

create index "IDX_e7314467f7167fd72cf601e646"
    on ar.s_geonims_closure (id_descendant);





create table ar.s_grounds
(
    created_at      timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at      timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by      integer,
    updated_by      integer,
    id              integer generated by default as identity
        constraint "PK_b9484f58b0d548d71647002d03f"
            primary key,
    rca             varchar,
    number          varchar                                                      not null,
    cadastre_number varchar,
    actual          boolean                                                      not null,
    full_address_ru  varchar,
    full_address_kz  varchar,
    shape           geometry(MultiPolygon, 4326),
    s_geonim_id     integer
        constraint "FK_28ac366ca4f4a80ab418d83546c"
            references ar.s_geonims,
    s_ats_id        integer
        constraint "FK_562c1766b538c153c87b467c3a2"
            references ar.s_ats
);

comment on table ar.s_grounds is 'Земельные участки';
comment on column ar.s_grounds.created_at is 'Дата-Время создания записи';
comment on column ar.s_grounds.updated_at is 'Дата-Время обновления записи';
comment on column ar.s_grounds.created_by is 'Кем создано';
comment on column ar.s_grounds.updated_by is 'Кем обновлено';
comment on column ar.s_grounds.rca is 'Регистрационный код адреса';
comment on column ar.s_grounds.number is 'Номер участка';
comment on column ar.s_grounds.cadastre_number is 'Кадастровый номер';
comment on column ar.s_grounds.actual is 'Действующее';

create index if not exists "IDX_s_grounds_shape"
    on ar.s_grounds using gist (shape);

create table ar.s_buildings
(
    created_at             timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at             timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by             integer,
    updated_by             integer,
    id                     integer generated by default as identity
        constraint "PK_8cc8b2f3faf21859d9a9e754689"
            primary key,
    name_kz                varchar,
    name_ru                varchar,
    rca                    varchar,
    number                 varchar                                                      not null,
    distance               integer   default 0                                          not null,
    actual                 boolean                                                      not null,
    this_is                varchar,
    shape                  geometry(Geometry, 4326),
    full_address_ru        varchar,
    full_address_kz        varchar,
    path                   jsonb,
    path_names_ru          varchar[],
    path_names_kz          varchar[],
    parent_id              integer
        constraint "FK_58828d06f31a109a54c0e501617"
            references ar.s_buildings,
    s_geonim_id            integer
        constraint "FK_c4110344bb8154aeb029c5e72de"
            references ar.s_geonims,
    s_ats_id               integer
        constraint "FK_69e5343f0348438dfd4f23dc1b0"
            references ar.s_ats,
    d_buildings_pointer_id integer
        constraint "FK_71e313a0da52eef8a8f1769d56a"
            references ar.d_buildings_pointers,
    s_ground_id            integer
        constraint "FK_bc42f998f0d9e3fedf1ca78eeee"
            references ar.s_grounds
);

comment on table ar.s_buildings is 'Первичные объекты адресации (здания)';
comment on column ar.s_buildings.created_at is 'Дата-Время создания записи';
comment on column ar.s_buildings.updated_at is 'Дата-Время обновления записи';
comment on column ar.s_buildings.created_by is 'Кем создано';
comment on column ar.s_buildings.updated_by is 'Кем обновлено';
comment on column ar.s_buildings.this_is is 'Подтип';
comment on column ar.s_buildings.rca is 'Регистрационный код адреса';
comment on column ar.s_buildings.number is 'Номер объекта';
comment on column ar.s_buildings.distance is 'Расстояние от начала дороги (км)';
comment on column ar.s_buildings.actual is 'Действующее';

create index if not exists "IDX_s_buildings_shape"
    on ar.s_buildings using gist (shape);

create table ar.s_buildings_closure
(
    id_ancestor   integer not null
        constraint "FK_5468cec46694d55b177eef15421"
            references ar.s_buildings
            on delete cascade,
    id_descendant integer not null
        constraint "FK_5ba596ebba7898a539e822e320e"
            references ar.s_buildings
            on delete cascade,
    constraint "PK_3076b204856e61a11414e84226a"
        primary key (id_ancestor, id_descendant)
);

create index "IDX_5468cec46694d55b177eef1542"
    on ar.s_buildings_closure (id_ancestor);

create index "IDX_5ba596ebba7898a539e822e320"
    on ar.s_buildings_closure (id_descendant);

create index s_buildings_path_names_ru_index
    on ar.s_buildings (path_names_ru);

create index s_buildings_path_names_ru_index
    on ar.s_buildings (path_names_kz);


create table ar.s_pb
(
    created_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    updated_at     timestamp default ('now'::text)::timestamp(6) with time zone not null,
    created_by     integer,
    updated_by     integer,
    id             integer generated by default as identity
        constraint "PK_8907cf4b1521aaee8413822bfef"
            primary key,
    rca            varchar,
    number         varchar                                                      not null,
    actual         boolean                                                      not null,
    full_address_ru  varchar,
    full_address_kz  varchar,
    d_room_type_id integer
        constraint "FK_8b7e456317e280ddcf2c558c963"
            references ar.d_rooms_types,
    s_building_id  integer
        constraint "FK_e5fd7c75e9019fd4c3f595c729f"
            references ar.s_buildings
);

comment on table ar.s_pb is 'Вторичные объекты адресации (помещения)';
comment on column ar.s_pb.created_at is 'Дата-Время создания записи';
comment on column ar.s_pb.updated_at is 'Дата-Время обновления записи';
comment on column ar.s_pb.created_by is 'Кем создано';
comment on column ar.s_pb.updated_by is 'Кем обновлено';
comment on column ar.s_pb.rca is 'Регистрационный код адреса';
comment on column ar.s_pb.number is 'Номер помещения';
comment on column ar.s_pb.actual is 'Действующее';

```

## 2. Import from address registry txt files

```bash
psql -U coc_admin -d coc

# потом

\copy ar.d_ats_types (id,code,value_kz,value_ru,short_value_kz,short_value_ru,actual) FROM '/backups/ar/d_ats_types.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.d_buildings_pointers (id,code,value_kz,value_ru,short_value_kz,short_value_ru,actual) FROM '/backups/ar/d_buildings_pointers.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.d_geonims_types (id,code,this_is,value_kz,value_ru,short_value_kz,short_value_ru,actual) FROM '/backups/ar/d_geonims_types.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.d_rooms_types (id,code,value_kz,value_ru,short_value_kz,short_value_ru,actual) FROM '/backups/ar/d_rooms_types.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.s_ats (id,parent_id,d_ats_type_id,rco,cato,name_kz,name_ru,actual) FROM '/backups/ar/s_ats.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

# удалите двойные кавычки из файла s_geonims.txt перед этим импортом
\copy ar.s_geonims (id,parent_id,s_ats_id,d_geonims_type_id,rco,cato,name_kz,name_ru,actual) FROM '/backups/ar/s_geonims.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.s_grounds (id,s_geonim_id,s_ats_id,rca,number,cadastre_number,actual) FROM '/backups/ar/s_grounds.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.s_buildings (id,s_geonim_id,s_ats_id,d_buildings_pointer_id,this_is,parent_id,s_ground_id,rca,number,distance,actual) FROM '/backups/ar/s_buildings.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')

\copy ar.s_pb (id,d_room_type_id,s_building_id,rca,number,actual) FROM '/backups/ar/s_pb.txt' WITH (FORMAT CSV, HEADER true, DELIMITER '|')
```

### 2.1. Сбросить счётчики id sequence

```sql
do $$
DECLARE
    mytables RECORD;
	cur_max INTEGER;
	max_id integer;
	id_col varchar := 'id';
BEGIN
    FOR mytables IN
			SELECT S.relname AS seq_name, C.attname AS id_col, T.relname AS table_name FROM pg_class AS S, pg_depend AS D, pg_class AS T, pg_attribute AS C
			WHERE S.relkind = 'S' AND S.oid = D.objid AND D.refobjid = T.oid AND D.refobjid = C.attrelid AND D.refobjsubid = C.attnum ORDER BY S.relname LOOP
		BEGIN
			BEGIN
				EXECUTE 'SELECT MAX('|| mytables.id_col ||') FROM '|| mytables.table_name||'' INTO cur_max;
				IF cur_max IS NULL OR cur_max = 0 THEN
					cur_max := 0;
				END IF;
				EXECUTE 'SELECT SETVAL('||quote_literal(mytables.seq_name)||', '|| cur_max || ')';
				EXCEPTION WHEN OTHERS THEN RAISE NOTICE '% ERROR setval: % %', mytables.table_name, SQLERRM, SQLSTATE;
			END;
		END;
    END LOOP;

	FOR mytables IN
			 select table_name from information_schema.tables where table_schema = 'ar' LOOP
		BEGIN
			BEGIN
				EXECUTE 'SELECT MAX('|| id_col ||') FROM ar.'||mytables.table_name INTO max_id;
				IF max_id IS NULL OR max_id = 0 THEN
					max_id := 0;
				END IF;
				EXECUTE format('SELECT setval('|| quote_literal(mytables.table_name|| '_' || id_col || '_seq') ||','|| max_id ||')');
				EXCEPTION WHEN OTHERS THEN RAISE NOTICE '% ERROR setval: % %', mytables.table_name, SQLERRM, SQLSTATE;
			END;
		END;
    END LOOP;
END;
$$;
```



## 3. Заполнить closure-table из таблицы смежности для `ar.s_ats`, `ar.s_buildings`, `ar.s_geonims` (там где есть parent_id)

### 3.1. Заполнить closure-table для `s_ats`

```sql
do $$
DECLARE
    myrow RECORD;
BEGIN
    FOR myrow IN
        WITH RECURSIVE my_cte AS
        (
            SELECT
                id AS ancestor,
                id AS descendant,
                0  AS depth
            FROM ar.s_ats

            UNION ALL

            SELECT
                CTE.ancestor  AS ancestor,
                C.id          AS descendant,
                CTE.depth + 1 AS depth
            FROM ar.s_ats AS C
            JOIN my_cte AS CTE
                ON C.parent_id = CTE.descendant
        )
        SELECT * FROM my_cte
    LOOP
        BEGIN
            EXECUTE 'INSERT INTO ar.s_ats_closure ("id_ancestor", "id_descendant") VALUES ('|| myrow.ancestor ||', '|| myrow.descendant ||')';
            EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'ERROR: closure record % %', SQLERRM, SQLSTATE;
        END;
    END LOOP;
END;
$$;
```

### 3.2. Заполнить closure-table для `s_geonims`

```sql
do $$
DECLARE
    myrow RECORD;
BEGIN
    FOR myrow IN
        WITH RECURSIVE my_cte AS
        (
            SELECT
                id AS ancestor,
                id AS descendant,
                0  AS depth
            FROM ar.s_geonims

            UNION ALL

            SELECT
                CTE.ancestor  AS ancestor,
                C.id          AS descendant,
                CTE.depth + 1 AS depth
            FROM ar.s_geonims AS C
            JOIN my_cte AS CTE
                ON C.parent_id = CTE.descendant
        )
        SELECT * FROM my_cte
    LOOP
        BEGIN
            EXECUTE 'INSERT INTO ar.s_geonims_closure ("id_ancestor", "id_descendant") VALUES ('|| myrow.ancestor ||', '|| myrow.descendant ||')';
            EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'ERROR: closure record % %', SQLERRM, SQLSTATE;
        END;
    END LOOP;
END;
$$;
```

### 3.3. Заполнить closure-table для `s_buildings`

```sql
do $$
DECLARE
    myrow RECORD;
BEGIN
    FOR myrow IN
        WITH RECURSIVE my_cte AS
        (
            SELECT
                id AS ancestor,
                id AS descendant,
                0  AS depth
            FROM ar.s_buildings

            UNION ALL

            SELECT
                CTE.ancestor  AS ancestor,
                C.id          AS descendant,
                CTE.depth + 1 AS depth
            FROM ar.s_buildings AS C
            JOIN my_cte AS CTE
                ON C.parent_id = CTE.descendant
        )
        SELECT * FROM my_cte
    LOOP
        BEGIN
            EXECUTE 'INSERT INTO ar.s_buildings_closure ("id_ancestor", "id_descendant") VALUES ('|| myrow.ancestor ||', '|| myrow.descendant ||')';
            EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'ERROR: closure record % %', SQLERRM, SQLSTATE;
        END;
    END LOOP;
END;
$$;
```

## 4. Заполнить полный адрес

Все операции выполнять в указанном порядке. Можно начать не с первого пункта, НО все остальные пункты должны быть выполнены.

### 4.1. Заполнить полный адрес, массив имён пути, путь для `s_ats`

```sql
UPDATE ar.s_ats g
SET path = (SELECT jsonb_agg(json_build_object(
                'id', a.id,
                'name_ru', a.name_ru,
                'name_kz', a.name_kz,
                'type_ru', t.value_ru,
                'type_kz', t.value_kz,
                'table', 's_ats'
        )) as path
        FROM ar.s_ats a
            JOIN ar.s_ats_closure ac ON a.id = ac.id_ancestor
            JOIN ar.d_ats_types t ON a.d_ats_type_id = t.id
        WHERE  ac.id_descendant = g.id AND a.id != 1),
    path_names_ru = (SELECT array_agg(a.name_ru)
        FROM ar.s_ats a
            JOIN ar.s_ats_closure ac ON a.id = ac.id_ancestor
        WHERE  ac.id_descendant = g.id AND a.id != 1),
    path_names_kz = (SELECT array_agg(a.name_kz)
        FROM ar.s_ats a
            JOIN ar.s_ats_closure ac ON a.id = ac.id_ancestor
        WHERE  ac.id_descendant = g.id AND a.id != 1);


UPDATE ar.s_ats g
SET full_address_ru = (SELECT string_agg(concat_ws(' ', elem->>'name_ru', elem->>'type_ru'), ', ') FROM ar.s_ats, LATERAL jsonb_array_elements(path) AS elem WHERE id = g.id),
    full_address_kz = (SELECT string_agg(concat_ws(' ', elem->>'name_kz', elem->>'type_kz'), ', ') FROM ar.s_ats, LATERAL jsonb_array_elements(path) AS elem WHERE id = g.id);
```

### 4.2. Заполнить полный адрес, массив имён пути, путь для `s_geonims`

```sql
UPDATE ar.s_geonims g
SET path = (SELECT jsonb_agg(json_build_object(
                'id', a.id,
                'name_ru', a.name_ru,
                'name_kz', a.name_kz,
                'type_ru', t.value_ru,
                'type_kz', t.value_kz,
                'table', 's_geonims'
        )) as path
        FROM ar.s_geonims a
            JOIN ar.s_geonims_closure ac ON a.id = ac.id_ancestor
            JOIN ar.d_geonims_types t ON a.d_geonims_type_id = t.id
        WHERE  ac.id_descendant = g.id),
    path_names_ru = (SELECT array_agg(a.name_ru)
        FROM ar.s_geonims a
            JOIN ar.s_geonims_closure ac ON a.id = ac.id_ancestor
        WHERE  ac.id_descendant = g.id),
    path_names_kz = (SELECT array_agg(a.name_kz)
        FROM ar.s_geonims a
            JOIN ar.s_geonims_closure ac ON a.id = ac.id_ancestor
        WHERE  ac.id_descendant = g.id);


UPDATE ar.s_geonims g
SET full_address_ru = (SELECT string_agg(concat_ws(' ', elem->>'name_ru', elem->>'type_ru'), ', ') FROM ar.s_geonims, LATERAL jsonb_array_elements(path) AS elem WHERE id = g.id),
    full_address_kz = (SELECT string_agg(concat_ws(' ', elem->>'name_kz', elem->>'type_kz'), ', ') FROM ar.s_geonims, LATERAL jsonb_array_elements(path) AS elem WHERE id = g.id);

-- для обновления полного адреса,пути, массива имён в s_geonims
UPDATE ar.s_geonims g
SET path = path || (SELECT path FROM ar.s_ats ate WHERE g.s_ats_id = ate.id),
    path_names_ru = path_names_ru ||  (SELECT path_names_ru FROM ar.s_ats ate WHERE g.s_ats_id = ate.id),
    path_names_kz = path_names_kz ||  (SELECT path_names_kz FROM ar.s_ats ate WHERE g.s_ats_id = ate.id),
    full_address_ru = full_address_ru || ', ' ||  (SELECT full_address_ru FROM ar.s_ats ate WHERE g.s_ats_id = ate.id),
    full_address_kz = full_address_kz || ', ' ||  (SELECT full_address_kz FROM ar.s_ats ate WHERE g.s_ats_id = ate.id);
```

### 4.3. Заполнить полный адрес, массив имён пути, путь для `s_buildings`

```sql
UPDATE ar.s_buildings g
SET path = i.path, path_names_ru = i.name, path_names_kz = i.name
FROM (SELECT ac.id_descendant,
             jsonb_agg(json_build_object(
                    'id', a.id,
                    'name_ru', a.number,
                    'name_kz', a.number,
                    'type_ru', t.value_ru,
                    'type_kz', t.value_kz,
                    'table', 's_buildings'
            )) AS path,
          array_agg(a.number) as name
          FROM ar.s_buildings a
               JOIN ar.s_buildings_closure ac ON a.id = ac.id_ancestor
               JOIN ar.d_buildings_pointers t ON a.d_buildings_pointer_id = t.id
          GROUP BY ac.id_descendant
          ) i
WHERE g.id = i.id_descendant;


UPDATE ar.s_buildings g
SET full_address_ru = i.adr_ru,
    full_address_kz = i.adr_kz
FROM (SELECT id,
             string_agg(concat_ws(' ', elem->>'name_ru', elem->>'type_ru'), ', ') AS adr_ru,
             string_agg(concat_ws(' ', elem->>'name_ru', elem->>'type_ru'), ', ') AS adr_kz
      FROM ar.s_buildings, LATERAL jsonb_array_elements(path) AS elem
      GROUP BY id
      ) i
WHERE g.id = i.id;

-- для обновления полного адреса,пути, массива имён в s_buildings
UPDATE ar.s_buildings g
SET path = g.path || i.path,
    path_names_ru = g.path_names_ru ||  i.path_names_ru,
    path_names_kz = g.path_names_kz ||  i.path_names_kz,
    full_address_ru = g.full_address_ru || ', ' ||  i.full_address_ru,
    full_address_kz = g.full_address_kz || ', ' ||  i.full_address_kz
FROM (SELECT id, path, path_names_ru, path_names_kz, full_address_ru, full_address_kz FROM ar.s_geonims) i
WHERE g.s_geonim_id = i.id;

```

### 4.4. Отметить населённые пункты как крайние элементы в зависимости от типа

```sql
UPDATE ar.s_ats SET is_leaf=TRUE WHERE d_ats_type_id IN (1, 2, 4, 6, 9, 37, 38, 45, 49, 53, 54, 55, 56, 57, 69, 70, 71, 72, 73);
```


## 5. Триггеры

<https://medium.com/@yusoofash/handling-hierarchical-data-with-closure-tables-in-postgresql-167aac3a74f2>

TODO: добавить depth

### 5.1. Триггер для INSERT `s_ats`

```sql
CREATE OR REPLACE FUNCTION insert_s_ats_closure()
RETURNS trigger AS
$BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN
      INSERT INTO ar.s_ats_closure (id_ancestor, id_descendant)
      VALUES(NEW.id, NEW.id);

      INSERT INTO ar.s_ats_closure (id_ancestor, id_descendant)
          SELECT p.id_ancestor, c.id_descendant
          FROM ar.s_ats_closure p, ar.s_ats_closure c
          WHERE p.id_descendant = NEW.parent_id AND c.id_ancestor = NEW.id;
      RETURN NEW;
  END IF;

  RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER insert_s_ats_closure_trigger
AFTER INSERT ON ar.s_ats
FOR EACH ROW
EXECUTE PROCEDURE insert_s_ats_closure();
```

### 5.2. Триггер для INSERT `s_geonims`

```sql
CREATE OR REPLACE FUNCTION insert_s_geonims_closure()
RETURNS trigger AS
$BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN
      INSERT INTO ar.s_geonims_closure (id_ancestor, id_descendant)
      VALUES(NEW.id, NEW.id);

      INSERT INTO ar.s_geonims_closure (id_ancestor, id_descendant)
          SELECT p.id_ancestor, c.id_descendant
          FROM ar.s_geonims_closure p, ar.s_geonims_closure c
          WHERE p.id_descendant = NEW.parent_id AND c.id_ancestor = NEW.id;
      RETURN NEW;
  END IF;

  RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER insert_s_geonims_closure_trigger
AFTER INSERT ON ar.s_geonims
FOR EACH ROW
EXECUTE PROCEDURE insert_s_geonims_closure();
```

### 5.3. Триггер для INSERT `s_buildings`

```sql
CREATE OR REPLACE FUNCTION insert_s_buildings_closure()
RETURNS trigger AS
$BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN
      INSERT INTO ar.s_buildings_closure (id_ancestor, id_descendant)
      VALUES(NEW.id, NEW.id);

      INSERT INTO ar.s_buildings_closure (id_ancestor, id_descendant)
          SELECT p.id_ancestor, c.id_descendant
          FROM ar.s_buildings_closure p, ar.s_buildings_closure c
          WHERE p.id_descendant = NEW.parent_id AND c.id_ancestor = NEW.id;
      RETURN NEW;
  END IF;

  RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER insert_s_buildings_closure_trigger
AFTER INSERT ON ar.s_buildings
FOR EACH ROW
EXECUTE PROCEDURE insert_s_buildings_closure();
```

### 5.4. Триггер для DELETE `s_ats`

```sql
CREATE OR REPLACE FUNCTION delete_s_ats_closure()
RETURNS trigger AS
$BODY$
BEGIN
    DELETE
    FROM ar.s_ats_closure O
    WHERE EXISTS (SELECT 1 FROM ar.s_ats_closure p, ar.s_ats_closure c
                  WHERE p.id_ancestor = O.id_ancestor
                    AND c.id_descendant = O.id_descendant
                    AND p.id_descendant = OLD.parent_id
                    AND c.id_ancestor = OLD.id);
    RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER delete_s_ats_closure_trigger
AFTER DELETE ON ar.s_ats
FOR EACH ROW EXECUTE PROCEDURE delete_s_ats_closure();
```

### 5.5. Триггер для DELETE `s_geonims`

```sql
CREATE OR REPLACE FUNCTION delete_s_geonims_closure()
RETURNS trigger AS
$BODY$
BEGIN
    DELETE
    FROM ar.s_geonims_closure O
    WHERE EXISTS (SELECT 1 FROM ar.s_geonims_closure p, ar.s_geonims_closure c
                  WHERE p.id_ancestor = O.id_ancestor
                    AND c.id_descendant = O.id_descendant
                    AND p.id_descendant = OLD.parent_id
                    AND c.id_ancestor = OLD.id);
    RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER delete_s_geonims_closure_trigger
AFTER DELETE ON ar.s_geonims
FOR EACH ROW EXECUTE PROCEDURE delete_s_geonims_closure();
```

### 5.6. Триггер для DELETE `s_buildings`

```sql
CREATE OR REPLACE FUNCTION delete_s_buildings_closure()
RETURNS trigger AS
$BODY$
BEGIN
    DELETE
    FROM ar.s_buildings_closure O
    WHERE EXISTS (SELECT 1 FROM ar.s_buildings_closure p, ar.s_buildings_closure c
                  WHERE p.id_ancestor = O.id_ancestor
                    AND c.id_descendant = O.id_descendant
                    AND p.id_descendant = OLD.parent_id
                    AND c.id_ancestor = OLD.id);
    RETURN OLD;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER delete_s_buildings_closure_trigger
AFTER DELETE ON ar.s_buildings
FOR EACH ROW EXECUTE PROCEDURE delete_s_buildings_closure();
```


### 5.7. Триггер для UPDATE `s_ats`

```sql
CREATE OR REPLACE FUNCTION update_s_ats_closure()
RETURNS trigger AS
$BODY$
BEGIN
    IF NEW.parent_id != OLD.parent_id THEN
        -- delete old subtree
        DELETE FROM ar.s_ats_closure
        WHERE id_descendant IN (SELECT id_descendant FROM ar.s_ats_closure WHERE id_ancestor = OLD.id)
        AND id_ancestor IN (SELECT id_ancestor FROM ar.s_ats_closure WHERE id_descendant = OLD.id AND id_ancestor != id_descendant);

        -- insert new subtree
        INSERT INTO ar.s_ats_closure (id_ancestor, id_descendant)
        SELECT supertree.id_ancestor, subtree.id_descendant
        FROM ar.s_ats_closure AS supertree
        CROSS JOIN ar.s_ats_closure AS subtree
        WHERE supertree.id_descendant = NEW.parent_id AND subtree.id_ancestor = OLD.id;
    END IF;

    RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_s_ats_closure_trigger
AFTER UPDATE ON ar.s_ats
FOR EACH ROW EXECUTE PROCEDURE update_s_ats_closure();
```

### 5.8. Триггер для UPDATE `s_geonims`

```sql
CREATE OR REPLACE FUNCTION update_s_geonims_closure()
RETURNS trigger AS
$BODY$
BEGIN
    IF NEW.parent_id != OLD.parent_id THEN
        -- delete old subtree
        DELETE FROM ar.s_geonims_closure
        WHERE id_descendant IN (SELECT id_descendant FROM ar.s_geonims_closure WHERE id_ancestor = OLD.id)
        AND id_ancestor IN (SELECT id_ancestor FROM ar.s_geonims_closure WHERE id_descendant = OLD.id AND id_ancestor != id_descendant);

        -- insert new subtree
        INSERT INTO ar.s_geonims_closure (id_ancestor, id_descendant)
        SELECT supertree.id_ancestor, subtree.id_descendant
        FROM ar.s_geonims_closure AS supertree
        CROSS JOIN ar.s_geonims_closure AS subtree
        WHERE supertree.id_descendant = NEW.parent_id AND subtree.id_ancestor = OLD.id;
    END IF;

    RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_s_geonims_closure_trigger
AFTER UPDATE ON ar.s_geonims
FOR EACH ROW EXECUTE PROCEDURE update_s_geonims_closure();
```

### 5.9. Триггер для UPDATE `s_buildings`

```sql
CREATE OR REPLACE FUNCTION update_s_buildings_closure()
RETURNS trigger AS
$BODY$
BEGIN
    IF NEW.parent_id != OLD.parent_id THEN
        -- delete old subtree
        DELETE FROM ar.s_buildings_closure
        WHERE id_descendant IN (SELECT id_descendant FROM ar.s_buildings_closure WHERE id_ancestor = OLD.id)
        AND id_ancestor IN (SELECT id_ancestor FROM ar.s_buildings_closure WHERE id_descendant = OLD.id AND id_ancestor != id_descendant);

        -- insert new subtree
        INSERT INTO ar.s_buildings_closure (id_ancestor, id_descendant)
        SELECT supertree.id_ancestor, subtree.id_descendant
        FROM ar.s_buildings_closure AS supertree
        CROSS JOIN ar.s_buildings_closure AS subtree
        WHERE supertree.id_descendant = NEW.parent_id AND subtree.id_ancestor = OLD.id;
    END IF;

    RETURN null;
END;
$BODY$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_s_buildings_closure_trigger
AFTER UPDATE ON ar.s_buildings
FOR EACH ROW EXECUTE PROCEDURE update_s_buildings_closure();
```

### 6. Как делать запросы SELECT

```sql
-- выбрать всех потомков
SELECT a.*
    FROM ar.s_ats a
    JOIN ar.s_ats_closure ac ON a.id = ac.id_descendant
WHERE ac.id_ancestor = :id AND a.id != :id;

-- выбрать всех предшественников
SELECT a.*
FROM ar.s_ats a
    JOIN ar.s_ats_closure ac
    ON a.id = ac.id_ancestor
WHERE  ac.id_descendant = :id AND a.id != :id;

-- выбрать всех предшественников и потомков (без себя)
SELECT a.*
FROM ar.s_ats a
    JOIN ar.s_ats_closure ac
    ON a.id = ac.id_ancestor OR a.id = ac.id_descendant
WHERE  (ac.id_ancestor = :id OR ac.id_descendant = :id) AND a.id != :id;
```
